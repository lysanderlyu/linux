!ifndef DEVICE_INCLUDED
!define DEVICE_INCLUDED
@startuml
class device <<device.puml>> {
    __public member__
    + struct **kobject** kobj
    + struct **device**		*parent
    + struct **device_private**	*p
    + struct **bus_type**	*bus		: type of bus device is on
    + struct **device_driver** *driver	: which driver has allocated this device
    + struct **device_dma_parameters** *dma_parms
    + struct **list_head**	dma_pools	: dma pools (if dma'ble)
    + struct **mutex**		mutex	: mutex to synchronize calls to * its driver.
    + struct **dev_links_info**	links
    + struct **dev_pm_info**	power
    + struct **dev_pm_domain**	*pm_domain
    + struct **list_head**	devres_head
    + struct **class**		*class
    + struct **iommu_group**	*iommu_group
    + struct **dev_iommu**	*iommu
    + enum **device_removable**	removable
    + --arch specific additions--
    + struct **dev_archdata**	archdata
    + struct **device_node**	*of_node : associated device tree node
    + struct **fwnode_handle**	*fwnode : firmware device node
    + const struct **device_type** *type
    + const struct **bus_dma_region** *dma_range_map
    + const struct **attribute_group** **groups	: optional groups
    + const char		*init_name : initial name of the device
    + u64		*dma_mask   : dma mask (if dma'able device)
    + u64		coherent_dma_mask : Like dma_mask, but for
    + 				     alloc_coherent mappings as
    + 				     not all hardware supports
    + 				     64 bit addresses for consistent
    + 				     allocations such descriptors.
    + u64	bus_dma_limit : upstream dma constraint
    + void		*platform_data	: Platform specific data, device core doesn't touch it
    + void		*driver_data	: Driver data, set and get with dev_set_drvdata/dev_get_drvdata
    + dev_t		devt	: dev_t, creates the sysfs "dev"
    + u32	    id	: device instance
    + spinlock_t    devres_lock
    + bool	offline_disabled:1
    + bool	offline:1
    + bool	of_node_reused:1
    + bool	state_synced:1
    + bool	can_match:1
    -- CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE OR
        CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU OR
        CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL--
    + bool	dma_coherent:1
    -- CONFIG_DMA_OPS_BYPASS -- 
    + bool	dma_ops_bypass : 1
    -- CONFIG_PROVE_LOCKING --
    + struct mutex	lockdep_mutex
    -- CONFIG_ENERGY_MODEL --
    + struct em_perf_domain	*em_pd
    -- CONFIG_GENERIC_MSI_IRQ_DOMAIN --
    + struct irq_domain	*msi_domain
    -- CONFIG_PINCTRL --
    + struct dev_pin_info	*pins
    -- CONFIG_GENERIC_MSI_IRQ --
    + raw_spinlock_t		msi_lock
    + struct list_head	msi_list
    -- CONFIG_DMA_OPS --
    + const struct dma_map_ops *dma_ops
    -- CONFIG_DMA_DECLARE_COHERENT --
    + struct dma_coherent_mem	*dma_mem : internal for coherent mem
    -- CONFIG_DMA_CMA --
    + struct cma *cma_area		: contiguous memory area for dma
    -- CONFIG_SWIOTLB --
    + struct io_tlb_mem *dma_io_tlb_mem
    -- CONFIG_NUMA --
    + int		numa_node	: NUMA node this device is close to
    __public method__
    + void	(*release)(struct device *dev)
}

@enduml
!endif
