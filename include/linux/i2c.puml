!ifndef I2C_INCLUDED
!define I2C_INCLUDED
@startuml
!include ../../include/linux/device/driver.puml
class i2c_client <<i2c.puml>> {
    __public member__
    unsigned short flags;		/* div., see below		*/
    #define I2C_CLIENT_PEC		0x04	/* Use Packet Error Checking */
    #define I2C_CLIENT_TEN		0x10	/* we have a ten bit chip address */
    					/* Must equal I2C_M_TEN below */
    #define I2C_CLIENT_SLAVE	0x20	/* we are the slave */
    #define I2C_CLIENT_HOST_NOTIFY	0x40	/* We want to use I2C host notify */
    #define I2C_CLIENT_WAKE		0x80	/* for board_info; true iff can wake */
    #define I2C_CLIENT_SCCB		0x9000	/* Use Omnivision SCCB protocol */
    					/* Must match I2C_M_STOP|IGNORE_NAK */
    
    unsigned short addr;		/* chip address - NOTE: 7bit	*/
    					/* addresses are stored in the	*/
    					/* _LOWER_ 7 bits		*/
    char name[I2C_NAME_SIZE];
    **struct i2c_adapter** *adapter;	/* the adapter we sit on	*/
    **struct device** dev;		/* the device structure		*/
    **int** init_irq;			/* irq set at initialization	*/
    **int** irq;			/* irq issued by device		*/
    **struct list_head** detected;
    __CONFIG_I2C_SLAVE__
    **i2c_slave_cb_t** slave_cb;	/* callback for slave mode	*/
    void *devres_group_id;		/* ID of probe devres group	*/
}
i2c_client *-- device
i2c_client o-- i2c_adapter
i2c_client *-- i2c_slave_cb_t

class i2c_adapter <<i2c.puml>> {
    __public membder__
    struct module *owner;
    unsigned int class;		  /* classes to allow probing for */
    const struct i2c_algorithm *algo; /* the algorithm to access the bus */
    void *algo_data;
    
    /* data fields that are valid for all devices	*/
    const struct i2c_lock_operations *lock_ops;
    struct rt_mutex bus_lock;
    struct rt_mutex mux_lock;
    
    int timeout;			/* in jiffies */
    int retries;
    struct device dev;		/* the adapter device */
    unsigned long locked_flags;	/* owned by the I2C core */
    
    #define I2C_ALF_IS_SUSPENDED		0
    #define I2C_ALF_SUSPEND_REPORTED	1
    
    int nr;
    char name[48];
    struct completion dev_released;
    
    struct mutex userspace_clients_lock;
    struct list_head userspace_clients;
    
    struct i2c_bus_recovery_info *bus_recovery_info;
    const struct i2c_adapter_quirks *quirks;
    
    struct irq_domain *host_notify_domain;
    struct regulator *bus_regulator;
}

class i2c_driver <<i2c.puml>> {
    __public member__
    unsigned **int** class;
    struct **device_driver** driver;
    const struct **i2c_device_id** *id_table;
    const **unsigned short** *address_list;
    struct **list_head** clients;

    __public method__
    __Standard driver model interfaces__
    int **(*probe)**(struct i2c_client *client, const struct i2c_device_id *id);
    int **(*remove)**(struct i2c_client *client);
    int **(*probe_new)**(struct i2c_client *client) : New driver model interface
    void **(*shutdown)**(struct i2c_client *client) : driver model interfaces that don't relate to enumeration

    int **(*command)**(struct i2c_client *client, unsigned int cmd, void *arg) : a ioctl like command that can be used to perform specific functions
    int **(*detect)**(struct i2c_client *client, struct i2c_board_info *info) : Device detection callback for automatic device creation
    
    void **(*alert)**(struct i2c_client *client, enum i2c_alert_protocol protocol, unsigned int data)
    /* Alert callback, for example for the SMBus alert protocol.
     * The format and meaning of the data value depends on the protocol.
     * For the SMBus alert protocol, there is a single bit of data passed
     * as the alert response's low bit ("event flag").
     * For the SMBus Host Notify protocol, the data corresponds to the
     * 16-bit payload data reported by the slave device acting as master.
     */
}
i2c_driver --|> device_driver
i2c_driver o-- i2c_device_id
i2c_driver ..> i2c_client

@enduml
!endif
